# Chapter 2

- 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라 한다.
- 프로그래머의 역할을 클래스 작성자(Creator)와 클라이언트 프로그래머 -> 클래스 소비자(?) 로 구분하는 것이 유용하다. - 클래스를 개발할때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

### 협력

- 객체간에는 메시지를 전송하는 것뿐
- 수신된 메시지를 처리하는 자신만의 방법을 메서드라 부른다.
- 메시지 / 메서드의 구분
- _메시지 전송 / 수신은 public 메서드를 호출하는 것으로 표현_
- - 메시지와 메서드를 구분하자!
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식클래스에게 위임하는 디자인 패턴을 TEMPLATe METHODS 패턴이라 한다

### 상속과 다형성

- 코드의 의존성과 실행시점의 의존성은 다를 수 있다 - 코드는 추상클래스에 의존하고, 실행시점에는 구현체에 의존하도록 유연한 구조 - 코드와 실행시점 의존성이 다르면 코드를 이해하기 어려워지나, 유연성을 얻을수 있는 트레이드 오프 관계. - 유연성 vs 가독성
- 차이에 의한 프로그래밍 - 공통된 부분을 상속받아 다른부분만 작성한다. - 상속은 두 클래스간의 관계를 정의하는 방법이다. - 자식클래스가 부모클래스를 대신하는 것을 UpCasting 이라 한다. - 자식클래스가 부모 클래스 타입으로 변환되는 Up-Casting
- 다형성 - **메시지와 메서드는 다르다!** - 상속 - 컴파일 시간 의존성과 실행시간 의존성을 다르게 만들 수 있는 객체지향 특성을 이용해 서로다른 메서드를 실행할 수 있게 한다. - 다형성? : 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력. 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다 --> Interface가 동일해야 한다. - 인터페이스 통일을 위해.. 상속을 사용 (`DiscountPolicy`) - `Lazy` or `Dynamic` Binding - 다형성은 상속이외에 다른 여러가지 방법으로 구현이 가능하다. - 인터페이스 - `isSatisfy`를 실체화(`implementation`) 하여 구현 - 이 경우에도 업캐스팅이 적용되며, 협력은 다형적이다!
- 추상화와 유연성 - 추상화 계층만 들여다보면 요구사항을 높은 수준에서 서술이 가능해진다 - 추상화를 이용하면 설계가 유연해진다 - 설계가 구체적인 상황에 결합되는것을 방지해 준다! - **Context Independency!** - 유연성이 필요한 곳에 추상화를 사용하라!
- 추상클래스 vs 인터페이스 Trade-off
- 코드재사용 - 상속 - 캡슐화를 위반한다. : 자식클래스는 부모클래스를 잘 알아야 하고, 강결합 된다. - 관계가 컴파일 시점에 결정되므로 실행시점에 객체를 변경하는게 불가능하다. - 인스턴스 변수로 연결되어 있으면, 실행시점에 인스턴스 변경이 가능하다! - 합성 (Composition) - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용한다. -> 합성 - 합성은 상속의 두가지 문제점을 모두 해결한다. 1. 인터페이스에 정의된 메시지로만 재사용이 가능하므로, 구현을 효과적으로 캡슐화 할 수 있다. 2. 의존하는 인스턴스를 교체하기 쉬우므로 설계를 유연하게 만든다. - 코드 재사용을 위해서는 합성보다 상속을 선호하기도 한다.

# Chap3 역할, 책임 협력

## 협력

1. 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는것이다.
   - 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있다.
   - 때문에, 자율적인 객체는 변경하기 쉬워진다.
2. 객체들 사이의 협력을 구성하는 일련의 요청과 응답의 흐름을 통해 기능이 구현된다.
3. 객체의 행동을 결정하는 것은 협력이다.
4. 객체의 상태를 결정하는 것은 행동이다.
5. 협력 -> 행동 -> 상태 (?)
6. 협력은 객체를 설계하는데 필요한 문맥을 제공한다.

## 책임

- 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합
- 객체의 책임은 무엇을 알고 있는가(knowing)와, 무엇을 할수 있는가(doing)로 구성되어 있다 - 하는것 (Doing) - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것 - 다른 객체의 행동을 시작시키는 것 - 다른 객체의 활동을 제어하고 조작하는 것 - 아는것(Knowing) - 사적인 정보에 관해 아는 것 - 관련된 객체에 관해 아는 것 - 자신이 유도(Derive/ Computed)하거나 계산할 수 있는 것에 대해 아는것
- 객체지향 개발에서 가장 중요한 능력은 **책임**을 능숙하게 **객체**에 할당하는 것
- 적절한 협력 -> 적절한 책임 -> 적절한 객체에 제공
- CRC(Candidate, Responsibility, Collaborator) Card

### 책임할당

- 객체지향 설계는 책임을 완료하는데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰 나간다.
- 책임주도설계 - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다. - 시스템 책임을 더 작은 책임으로 분할한다 - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다 - 해당 객체 또는 역할에게 책임을 할당함으로 두 객체가 협력하게 된다.

### 메시지가 객체를 결정한다

- 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택한다.
- 객체가 최소한의 인터페이스를 가질 수 있게 된다.
- 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.

### 행동이 상태를 결정한다

- 객체는 다른객체에게 제공하는 행동에 의해 결정된다.
- 객체의 상태가 아니라 행동에 초점을 맞춰야 한다!!!
- 협력이라는 문맥 안에서 객체를 생각해야 한다.
- 상태는 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다.

## 역할

### 역할과 협력

- 익명의 역할을 찾고, 수행가능한 객체를 선택하는 방식으로 설계를 진행함.

### 유연하고 재사용 가능한 협력

- 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있다.
- 역할은 두 종류의 구체적인 객체를 포괄하는 **추상화** 이다.
- 역할을 이용하면 불필요한 중복코드를 제거할 수 있다. + 협력이 더 유연해졌다.
- 역할의 구현 : 추상클래스 / 인터페이스 - 추상클래스 : 책임의 일부를 구현 - 인터페이스 : 책임의 집합만을 나열

### 객체 VS 역할

- 책임을 수행하는 대상이 한종류이면 객체
- 여러종류의 객체들이 참여할 수 있으면 역할
- 협력 -reference-> 역할 -select from-> 객체 -instance of-> 클래스
- 중요한 것은 책임이다.

### 역할과 추상화

### 배우와 배역
