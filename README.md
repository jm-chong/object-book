# Chapter 2

- 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라 한다.
- 프로그래머의 역할을 클래스 작성자(Creator)와 클라이언트 프로그래머 -> 클래스 소비자(?) 로 구분하는 것이 유용하다. - 클래스를 개발할때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

### 협력

- 객체간에는 메시지를 전송하는 것뿐
- 수신된 메시지를 처리하는 자신만의 방법을 메서드라 부른다.
- 메시지 / 메서드의 구분
- _메시지 전송 / 수신은 public 메서드를 호출하는 것으로 표현_
- - 메시지와 메서드를 구분하자!
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식클래스에게 위임하는 디자인 패턴을 TEMPLATe METHODS 패턴이라 한다

### 상속과 다형성

- 코드의 의존성과 실행시점의 의존성은 다를 수 있다 - 코드는 추상클래스에 의존하고, 실행시점에는 구현체에 의존하도록 유연한 구조 - 코드와 실행시점 의존성이 다르면 코드를 이해하기 어려워지나, 유연성을 얻을수 있는 트레이드 오프 관계. - 유연성 vs 가독성
- 차이에 의한 프로그래밍 - 공통된 부분을 상속받아 다른부분만 작성한다. - 상속은 두 클래스간의 관계를 정의하는 방법이다. - 자식클래스가 부모클래스를 대신하는 것을 UpCasting 이라 한다. - 자식클래스가 부모 클래스 타입으로 변환되는 Up-Casting
- 다형성 - **메시지와 메서드는 다르다!** - 상속 - 컴파일 시간 의존성과 실행시간 의존성을 다르게 만들 수 있는 객체지향 특성을 이용해 서로다른 메서드를 실행할 수 있게 한다. - 다형성? : 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력. 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다 --> Interface가 동일해야 한다. - 인터페이스 통일을 위해.. 상속을 사용 (`DiscountPolicy`) - `Lazy` or `Dynamic` Binding - 다형성은 상속이외에 다른 여러가지 방법으로 구현이 가능하다. - 인터페이스 - `isSatisfy`를 실체화(`implementation`) 하여 구현 - 이 경우에도 업캐스팅이 적용되며, 협력은 다형적이다!
- 추상화와 유연성 - 추상화 계층만 들여다보면 요구사항을 높은 수준에서 서술이 가능해진다 - 추상화를 이용하면 설계가 유연해진다 - 설계가 구체적인 상황에 결합되는것을 방지해 준다! - **Context Independency!** - 유연성이 필요한 곳에 추상화를 사용하라!
- 추상클래스 vs 인터페이스 Trade-off
- 코드재사용 - 상속 - 캡슐화를 위반한다. : 자식클래스는 부모클래스를 잘 알아야 하고, 강결합 된다. - 관계가 컴파일 시점에 결정되므로 실행시점에 객체를 변경하는게 불가능하다. - 인스턴스 변수로 연결되어 있으면, 실행시점에 인스턴스 변경이 가능하다! - 합성 (Composition) - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용한다. -> 합성 - 합성은 상속의 두가지 문제점을 모두 해결한다. 1. 인터페이스에 정의된 메시지로만 재사용이 가능하므로, 구현을 효과적으로 캡슐화 할 수 있다. 2. 의존하는 인스턴스를 교체하기 쉬우므로 설계를 유연하게 만든다. - 코드 재사용을 위해서는 합성보다 상속을 선호하기도 한다.

# Chap3 역할, 책임 협력

## 협력

1. 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는것이다.
   - 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있다.
   - 때문에, 자율적인 객체는 변경하기 쉬워진다.
2. 객체들 사이의 협력을 구성하는 일련의 요청과 응답의 흐름을 통해 기능이 구현된다.
3. 객체의 행동을 결정하는 것은 협력이다.
4. 객체의 상태를 결정하는 것은 행동이다.
5. 협력 -> 행동 -> 상태 (?)
6. 협력은 객체를 설계하는데 필요한 문맥을 제공한다.

## 책임

- 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합
- 객체의 책임은 무엇을 알고 있는가(knowing)와, 무엇을 할수 있는가(doing)로 구성되어 있다 - 하는것 (Doing) - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것 - 다른 객체의 행동을 시작시키는 것 - 다른 객체의 활동을 제어하고 조작하는 것 - 아는것(Knowing) - 사적인 정보에 관해 아는 것 - 관련된 객체에 관해 아는 것 - 자신이 유도(Derive/ Computed)하거나 계산할 수 있는 것에 대해 아는것
- 객체지향 개발에서 가장 중요한 능력은 **책임**을 능숙하게 **객체**에 할당하는 것
- 적절한 협력 -> 적절한 책임 -> 적절한 객체에 제공
- CRC(Candidate, Responsibility, Collaborator) Card

### 책임할당

- 객체지향 설계는 책임을 완료하는데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰 나간다.
- 책임주도설계 - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다. - 시스템 책임을 더 작은 책임으로 분할한다 - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다 - 해당 객체 또는 역할에게 책임을 할당함으로 두 객체가 협력하게 된다.

### 메시지가 객체를 결정한다

- 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택한다.
- 객체가 최소한의 인터페이스를 가질 수 있게 된다.
- 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.

### 행동이 상태를 결정한다

- 객체는 다른객체에게 제공하는 행동에 의해 결정된다.
- 객체의 상태가 아니라 행동에 초점을 맞춰야 한다!!!
- 협력이라는 문맥 안에서 객체를 생각해야 한다.
- 상태는 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다.

## 역할

### 역할과 협력

- 익명의 역할을 찾고, 수행가능한 객체를 선택하는 방식으로 설계를 진행함.

### 유연하고 재사용 가능한 협력

- 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있다.
- 역할은 두 종류의 구체적인 객체를 포괄하는 **추상화** 이다.
- 역할을 이용하면 불필요한 중복코드를 제거할 수 있다. + 협력이 더 유연해졌다.
- 역할의 구현 : 추상클래스 / 인터페이스 - 추상클래스 : 책임의 일부를 구현 - 인터페이스 : 책임의 집합만을 나열

### 객체 VS 역할

- 책임을 수행하는 대상이 한종류이면 객체
- 여러종류의 객체들이 참여할 수 있으면 역할
- 협력 -reference-> 역할 -select from-> 객체 -instance of-> 클래스
- 중요한 것은 책임이다.

### 역할과 추상화

### 배우와 배역

# Chap4 설계품질과 트레이드오프

## 데이터 중심의 영화예매 시스템

- 객체지향 설계에서는 '상태'(=데이터)를 분할의 중심으로 삼거나 - 데이터를 조작하는데 필요한 오퍼레이션을 정의 - 객체의 상태에 초점 - 객체는 독립된 데이터 덩어리
- '책임'을 분할의 중심축으로 삼는 방법이 있다. - 다른 객체가 요청할 수 있는 오퍼레이션 처리를 위한 상태를 보관. - 객체의 행동에 초점 - 객체는 협력하는 공동체의 일원

### 데이터를 중심으로 하는 영화예매 시스템

#### 캡슐화 : 변경가능성이 높은 부분을 내부로 숨기는 추상화 기법.

- 변경의 여파를 조절할 수 있다. (내부를 감춘다)
- 변경이 잦으면 (내부) 구현, 안정되면 인터페이스
- 캡슐화의 정도가 객체의 응집도와 결합도를 결정한다.

#### 응집도와 결합도 : 변경과 관련이 있다.

- 응집도 (High Cohesion) - 모듈내의 요소들이 하나의 목적을 위해 긴밀히 협력하면 높은 응집도 - 변경의 관점에서 : 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도. - 하나의 변경에 대해 하나의 모듈만 변경되면 응집도가 높음. (좋은것) - 응집도가 높으면 변경의 대상과 범위가 명확해져서 변경이 쉬워짐.
- 결합도 (Low Coupling) - 다른 모듈에 대해 얼마나 많이 알고 있는지 - 변경의 관점에서, 한모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도.

### 데이터 중심 영화 예매 시스템의 문제

- 데이터 중심의 설계는 캡슐화를 위반하기 쉽다.
- 캡슐화 위반 - 객체가 다양한 상황에서 사용될 수 있을거라는 막연한 추측을 기반으로 설계를 하게되면 과도한 내부구현을 노출하는 메소드를 추가할 수 밖에 없다.
- 높은 결합도 - get methods의 노출은 결국 그 인스턴스 변수를 노출시키는 꼴이 된다. - 여러 데이터 객체를 사용하는 제어로직이 특정 객체안에 집중되기 때문에, 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합이된다. - `ReservationAgency`에 모든 의존성이 모이게 된다. (`CommonView.ts`) - 시스템 안의 어떠한 변경되 `ReservationAgency`의 변경을 유발하게 된다.
- 낮은 응집도 - 여러가지 다른 목적의 로직이 하나의 모듈안에 있을때 낮은 응집도. - 하나를 고치면 다른쪽 코드에도 영향이 가게된다. - 변경시 여러 코드를 동시에 고쳐야 한다. - `Single Responsibility Principle`

### 자율적인 객체를 향해

- 캡슐화를 지켜라 - 캡슐화는 설계의 제1원리이다. - 높은 응집도와 낮은 결합도가 필요.
- `Rectangle` 의 너비와 높이를 증가시키는 코드는, `Rectangle`안에 두어서 `책임`을 이동시킨다. 이것이 바로 객체가 자기 스스로 책임진다는 말의 의미이다.
- 스스로 자신의 데이터를 책임지는 객체

### 캡슐화 위반

- 캡슐화는 변하는 어떤 것이든 감추는 것이다.

### 높은 결합도

- `DiscountCondition` - `Movie` 간에 결합도가 높다.

### 낮은 응집도

- 할인조건이 변경되면, `DiscountCondition`, `Movie`, `Screening`을 함께 변경해야 한다.

## 데이터중심 설계의 문제점!

- 데이터에 대한 결정 강요 -> 내부구현에 초점을 맞추게 됨.
- 올바른 객체지향 설계의 무게중심은 객체의 외부에 맞춰져야 한다.

# Chapter 5 : 책임 할당하기

- 책임에 초점을 맞춰 설계 -> 어떤객체에게 어떤 책임을 할당할것인가?
- `GRASP` 패턴을 알아보자

## 책임주도 설계를 향해

### 객체는 데이터보다 행동을 먼저 결정하라

- 객체는 데이터보다, 외부에 제공하는 행동이 중요하다.
- 객체에게 어떤 책임을 할당해야 하는가? `협력`에서 실마리를 찾을 수 있다.

### 협력이라는 문맥 안에서 책임을 결정하라

- 책임은 객체가 참여하는 협력에 적합해야 한다.
- 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다.
- 메시지를 결정한 후에 객체를 선택해야 한다.
- `메시지를 누구에게 전송할 것인가?`
- 메시지를 전송하기 때문에 객체를 갖게된 것이다.

### 책임주도 설계

1. 시스템 책임을 파악한다
2. 더 작은 책임으로 분할한다
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

## 책임 할당을 위한 `GRASP` 패턴

### General Responsibility Assignment Software Pattern (일반적인 책임 할당을 위한 소프트웨어 패턴)

-
